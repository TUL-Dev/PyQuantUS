# Standard library imports
import logging
import os
from typing import Tuple, List

# Third-party imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
from scipy.signal import hilbert, stft
from scipy.optimize import curve_fit
from scipy.special import hermite, factorial
from scipy.fft import fft
from tqdm import tqdm

# Local application imports
from pyquantus.utc.objects import UltrasoundImage, AnalysisConfig, Window
from pyquantus.utc.transforms import computeHanningPowerSpec, computeSpectralParams

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class UtcAnalysis:
    """Complete ultrasound tissue characterization (UTC) analysis of an ultrasound image given 
    a corresponding phantom image.

    This class supports both scan converted and non-scan converted images. UTC analysis
    is performed on each window generated by the `generateRoiWindows` method. Utc 
    analysis corresponds to the computation of tissue characterization-related parameters.
    The midband fit, spectral slope, and spectral intercept parameters have been validated using
    the frequency domain of each window. The Nakagami parameters, attenuation coefficient,
    backscatter coefficient, effective scatterer diameter, and effective scatterer concentration
    all have been implemented and reviewed, but still have not been validated in practice.

    Attributes:
        ultrasoundImage (UltrasoundImage): Stores image and RF info for image and phantom.
        config (AnalysisConfig): Stores analysis configuration parameters.
        roiWindows (List[Window]): List of windows generated by `generateRoiWindows`.
        waveLength (float): Wavelength of the ultrasound signal in mm.
        nakagamiParams (Tuple): Nakagami parameters (w, u) for the entire ROI.
        attenuationCoef (float): Attenuation coefficient of the entire ROI at the center frequency (dB/cm/MHz).
        backScatterCoef (float): Backscatter coefficient of the entire ROI at the center frequency (1/cm-sr).
        effectiveScattererDiameter (float): Effective scatterer diameter of the entire ROI (µm).
        effectiveScattererConcentration (float): Effective scatterer concentration of the entire ROI (dB/mm^3).
        refAttenuation (float): Total attenuation coefficient of the reference phantom at the center frequency (dB/cm/MHz).
        refBackScatterCoef (float): Backscatter coefficient of the reference phantom at the center frequency (1/cm-sr).
        scSplineX (np.ndarray): Spline x-coordinates in scan converted coordinates.
        splineX (np.ndarray): Spline x-coordinates in pre-scan converted coordinates.
        scSplineY (np.ndarray): Spline y-coordinates in scan converted coordinates.
        splineY (np.ndarray): Spline y-coordinates in pre-scan converted coordinates.
    """
    
    ###################################################################################
    # 
    ###################################################################################
    def __init__(self):
        self.ultrasoundImage: UltrasoundImage
        self.config: AnalysisConfig
        self.roiWindows: List[Window] = []
        self.waveLength: float
        self.nakagamiParams: Tuple
        self.refBackScatterCoef: float
        self.effectiveScattererDiameter: float
        self.effectiveScattererConcentration: float
        self.refAttenuation: float

        self.scSplineX: np.ndarray # pix
        self.splineX: np.ndarray # pix
        self.scSplineY: np.ndarray # pix
        self.splineY: np.ndarray # pix
        self.computeExtraParamaps = False

    ###################################################################################
    # Initialize analysis config
    ###################################################################################
    def initAnalysisConfig(self):
        """Compute the wavelength of the ultrasound signal and 
        set default config values if not pre-loaded.
        """
        speedOfSoundInTissue = 1540  # m/s
        self.waveLength = (
            speedOfSoundInTissue / self.config.centerFrequency
        ) * 1000  # mm
        if not hasattr(self.config, 'axWinSize'): # not pre-loaded config
            self.config.axWinSize = 10 * self.waveLength
            self.config.latWinSize = 10 * self.waveLength
            self.config.axialOverlap = 0.5; self.config.lateralOverlap = 0.5
            self.config.windowThresh = 0.95

    ###################################################################################
    # 
    ###################################################################################
    def splineToPreSc(self):
        """Convert spline coordinates from scan converted to pre-scan converted."""
        self.splineX = np.array([self.ultrasoundImage.xmap[int(y), int(x)] for x, y in zip(self.scSplineX, self.scSplineY)])
        self.splineY = np.array([self.ultrasoundImage.ymap[int(y), int(x)] for x, y in zip(self.scSplineX, self.scSplineY)])

    ###################################################################################
    #
    ###################################################################################
    def generateRoiWindows(self):
        """Generate windows for UTC analysis based on user-defined spline."""
        # Some axial/lateral dims
        axialPixSize = round(self.config.axWinSize / self.ultrasoundImage.axialResRf) # mm/(mm/pix)
        lateralPixSize = round(self.config.latWinSize / self.ultrasoundImage.lateralResRf) # mm(mm/pix)
        axial = list(range(self.ultrasoundImage.rf.shape[0]))
        lateral = list(range(self.ultrasoundImage.rf.shape[1]))

        # Overlap fraction determines the incremental distance between ROIs
        axialIncrement = axialPixSize * (1 - self.config.axialOverlap)
        lateralIncrement = lateralPixSize * (1 - self.config.lateralOverlap)

        # Determine ROIS - Find Region to Iterate Over
        axialStart = max(min(self.splineY), axial[0])
        axialEnd = min(max(self.splineY), axial[-1] - axialPixSize)
        lateralStart = max(min(self.splineX), lateral[0])
        lateralEnd = min(max(self.splineX), lateral[-1] - lateralPixSize)

        self.roiWindows = []

        # Determine all points inside the user-defined polygon that defines analysis region
        # The 'mask' matrix - "1" inside region and "0" outside region
        # Pair x and y spline coordinates
        spline = []
        if len(self.splineX) != len(self.splineY):
            print("Spline has unequal amount of x and y coordinates")
            return
        for i in range(len(self.splineX)):
            spline.append((self.splineX[i], self.splineY[i]))

        img = Image.new("L", (self.ultrasoundImage.rf.shape[1], self.ultrasoundImage.rf.shape[0]), 0)
        ImageDraw.Draw(img).polygon(spline, outline=1, fill=1)
        mask = np.array(img)

        for axialPos in np.arange(axialStart, axialEnd, axialIncrement):
            for lateralPos in np.arange(lateralStart, lateralEnd, lateralIncrement):
                # Convert axial and lateral positions in mm to Indices
                axialAbsAr = abs(axial - axialPos)
                axialInd = np.where(axialAbsAr == min(axialAbsAr))[0][0]
                lateralAbsAr = abs(lateral - lateralPos)
                lateralInd = np.where(lateralAbsAr == min(lateralAbsAr))[0][0]

                # Determine if ROI is Inside Analysis Region
                maskVals = mask[
                    axialInd : (axialInd + axialPixSize),
                    lateralInd : (lateralInd + lateralPixSize),
                ]

                # Define Percentage Threshold
                totalNumberOfElementsInRegion = maskVals.size
                numberOfOnesInRegion = len(np.where(maskVals == 1)[0])
                percentageOnes = numberOfOnesInRegion / totalNumberOfElementsInRegion

                if percentageOnes > self.config.windowThresh:
                    # Add ROI to output structure, quantize back to valid distances
                    newWindow = Window()
                    newWindow.left = int(lateral[lateralInd])
                    newWindow.right = int(lateral[lateralInd + lateralPixSize - 1])
                    newWindow.top = int(axial[axialInd])
                    newWindow.bottom = int(axial[axialInd + axialPixSize - 1])
                    self.roiWindows.append(newWindow)

    ###################################################################################
    # 
    ###################################################################################
    def computeUtcWindows(self, extraParams=True, bscFreq=None, extraParamapParams=False) -> int:
        """Compute UTC parameters for each window in the ROI.
        
        extraParams (bool): Flag on whether to compute non-validated parameters.
        bscFreq (int): Frequency on which to compute backscatter coefficient (MHz).
        
        Returns:
            int: 0 if successful, -1 if `generateRoiWindows` has not been 
            run or if windows are too large for ROI.
        """
        if not len(self.roiWindows):
            print("Run 'generateRoiWindows' first")
            return -1
        
        if bscFreq is None:
            bscFreq = self.config.centerFrequency
            
        self.computeExtraParamaps = extraParams
    
        fs = self.config.samplingFrequency
        f0 = self.config.transducerFreqBand[0]
        f1 = self.config.transducerFreqBand[1]
        lowFreq = self.config.analysisFreqBand[0]
        upFreq = self.config.analysisFreqBand[1]

        # Compute MBF, SS, and SI parameters for each window
        for window in tqdm(self.roiWindows):
            # Compute normalized power spectrum (dB)
            imgWindow = self.ultrasoundImage.rf[window.top: window.bottom+1, window.left: window.right+1]
            refWindow = self.ultrasoundImage.phantomRf[window.top: window.bottom+1, window.left: window.right+1]
            f, ps = computeHanningPowerSpec(
                imgWindow, f0, f1, fs
            ) 
            ps = 20 * np.log10(ps)
            f, rPs = computeHanningPowerSpec(
                refWindow, f0, f1, fs
            )
            rPs = 20 * np.log10(rPs)
            nps = np.asarray(ps) - np.asarray(rPs)

            window.results.nps = nps
            window.results.ps = np.asarray(ps)
            window.results.rPs = np.asarray(rPs)
            window.results.f = np.asarray(f)

            # Compute MBF, SS, and SI
            mbf, _, _, p = computeSpectralParams(nps, f, lowFreq, upFreq)
            window.results.mbf = mbf # dB
            window.results.ss = p[0]*1e6 # dB/MHz
            window.results.si = p[1] # dB
            
            if self.computeExtraParamaps:
                attCoef = self.computeAttenuationCoef(imgWindow, refWindow, windowDepth=min(100, imgWindow.shape[0]//3))
                bsc = self.computeBackscatterCoefficient(f, ps, rPs, attCoef, bscFreq, roiDepth=imgWindow.shape[0])
                uNakagami = self.computeNakagamiParams(imgWindow)[1]
                window.results.attCoef = attCoef # dB/cm/MHz
                window.results.bsc = bsc # 1/cm-sr
                window.results.uNakagami = uNakagami
            
        minLeft = min([window.left for window in self.roiWindows])
        maxRight = max([window.right for window in self.roiWindows])
        minTop = min([window.top for window in self.roiWindows])
        maxBottom = max([window.bottom for window in self.roiWindows])

        if extraParams:
            imgWindow = self.ultrasoundImage.rf[minTop: maxBottom+1, minLeft: maxRight+1]
            refWindow = self.ultrasoundImage.phantomRf[minTop: maxBottom+1, minLeft: maxRight+1]
            self.nakagamiParams = self.computeNakagamiParams(imgWindow) # computing for entire ROI, but could also be easily computed for each window
            # self.effectiveScattererDiameter, self.effectiveScattererConcentration = self.computeEsdac(imgWindow, refWindow, apertureRadiusCm=6)
        
        return 0
    
    ###################################################################################
    # 
    ###################################################################################
    def computeAttenuationCoef(self, rfData: np.ndarray, refRfData: np.ndarray, overlap=50, windowDepth=100) -> float:
        """Compute the local attenuation coefficient of the ROI using the Spectral Difference
        Method for Local Attenuation Estimation. This method computes the attenuation coefficient
        for multiple frequencies and returns the slope of the attenuation as a function of frequency.
        Args:
            rfData (np.ndarray): RF data of the ROI (n lines x m samples).
            refRfData (np.ndarray): RF data of the phantom (n lines x m samples).
            overlap (float): Overlap percentage for analysis windows.
            windowDepth (int): Depth of each window in samples.
        Returns:
            float: Local attenuation coefficient of the ROI for the central frequency (dB/cm/MHz).
            Updated and verified : Feb 2025 - IR
        """
        samplingFrequency = self.config.samplingFrequency
        startFrequency = self.config.analysisFreqBand[0]
        endFrequency = self.config.analysisFreqBand[1]
        # Initialize arrays for storing intensities (log of power spectrum for each frequency)
        psSample = [];  # ROI power spectra
        psRef = [];  # Phantom power spectra
        startIdx = 0
        endIdx = windowDepth
        windowCenterIndices = []
        counter = 0
        # Loop through the windows in the RF data
        while endIdx < rfData.shape[0]:
            subWindowRf = rfData[startIdx: endIdx]
            f, ps = computeHanningPowerSpec(subWindowRf, startFrequency, endFrequency, samplingFrequency)
            psSample.append(20*np.log10(ps))  # Log scale intensity for the ROI
            refSubWindowRf = refRfData[startIdx: endIdx]
            refF, refPs = computeHanningPowerSpec(refSubWindowRf, startFrequency, endFrequency, samplingFrequency)
            psRef.append(20*np.log10(refPs))  # Log scale intensity for the phantom
            windowCenterIndices.append((startIdx + endIdx) // 2)
            startIdx += int(windowDepth*(1-(overlap/100)))
            endIdx = startIdx + windowDepth
            counter += 1
        # Convert window depths to cm
        axialResCm = self.ultrasoundImage.axialResRf / 10
        windowDepthsCm = np.array(windowCenterIndices) * axialResCm
        attenuationCoefficients = []  # One coefficient for each frequency
        f = f / 1e6
        psSample = np.array(psSample)
        psRef = np.array(psRef)
        midIdx = f.shape[0] // 2  # Middle index
        startIdx = max(0, midIdx - 25)  # Start index for slicing
        endIdx = min(f.shape[0], midIdx + 25)  # End index for slicing
        # Compute attenuation for each frequency
        for fIdx in range(startIdx, endIdx):
            normalizedIntensities = np.subtract(psSample[:, fIdx], psRef[:, fIdx])
            p = np.polyfit(windowDepthsCm, normalizedIntensities, 1)
            localAttenuation = self.refAttenuation * f[fIdx] - (1 / 4) * p[0]  # dB/cm
            attenuationCoefficients.append( localAttenuation / f[fIdx])  # dB/cm/MHz
        attenuationCoef=np.mean(attenuationCoefficients)
        return attenuationCoef
    
    ###################################################################################
    # 
    ###################################################################################
    def computeBackscatterCoefficient(self, freqArr: np.ndarray, scanPs: np.ndarray, refPs: np.ndarray, attCoef: float,
                                      frequency: int, roiDepth: int) -> float:
        
        """Compute the backscatter coefficient of the ROI using the reference phantom method.
        Assumes instrumentation and beam terms have the same effect on the signal from both 
        image and phantom. 
        source: Yao et al. (1990) : https://doi.org/10.1177/016173469001200105. PMID: 2184569
        Args:
            freqArr (np.ndarray): Frequency array of power spectra (Hz).
            scanPs (np.ndarray): Power spectrum of the analyzed scan at the current region.
            refPs (np.ndarray): Power spectrum of the reference phantom at the currentn region.
            attCoef (float): Attenuation coefficient of the current region (dB/cm/MHz).
            frequency (int): Frequency on which to compute backscatter coefficient (should 
                    match frequency of self.refBackScatterCoefficient) (Hz).
            roiDepth (int): Depth of the start of the ROI in samples.
            
        Returns:
            float: Backscatter coefficient of the ROI for the central frequency (1/cm-sr).
            Updated and verified : Feb 2025 - IR
        """
        index = np.argmin(np.abs(freqArr - frequency))
        psSample=(scanPs[index])
        psRef=(refPs[index])
        sRatio = psSample/psRef
        
        npConversionFactor = np.log(10) / 20 
        convertedAttCoef = attCoef * npConversionFactor  # dB/cm/MHz -> Np/cm/MHz
        convertedRefAttCoef = self.refAttenuation * npConversionFactor # dB/cm/MHz -> Np/cm/MHz
        windowDepthCm = roiDepth*self.ultrasoundImage.axialResRf/10 # cm
        convertedAttCoef *= frequency/1e6 # Np/cm
        convertedRefAttCoef *= frequency/1e6 # Np/cm        
        attComp=np.exp(4*windowDepthCm *(convertedAttCoef-convertedRefAttCoef)) 
        bsc = sRatio*self.refBackScatterCoef*attComp
            
        return bsc
    
    ###################################################################################
    # 
    ###################################################################################
    def computeNakagamiParams(self, rfData: np.ndarray) -> Tuple[float, float]:
        """Compute Nakagami parameters for the ROI.
        source: Tsui, P. H., Wan, Y. L., Huang, C. C. & Wang, M. C. 
        Effect of adaptive threshold filtering on ultrasonic Nakagami 
        parameter to detect variation in scatterer concentration. Ultrason. 
        Imaging 32, 229–242 (2010). https://doi.org/10.1177%2F016173461003200403

        Args:
            rfData (np.ndarray): RF data of the ROI (n lines x m samples).
            
        Returns:
            Tuple: Nakagami parameters (w, u) for the ROI.
        """
        
        r = np.abs(hilbert(rfData, axis=1))
        w = np.nanmean(r ** 2, axis=1)
        u = (w ** 2) / np.var(r ** 2, axis=1)

        # Added this to get single param values
        w = np.nanmean(w)
        u = np.nanmean(u)

        return w, u
    
    ###################################################################################
    # 
    ###################################################################################
    def computeEsdac(self, rfData: np.ndarray, refRfData: np.ndarray, apertureRadiusCm: float) -> Tuple[float, float]:
        """Compute the effective scatterer diameter and concentration of the ROI.
        source: Muleki-Seya et al. https://doi.org/10.1177/0161734617729159
        
        Args:
            rfData (np.ndarray): RF data of the ROI (n lines x m samples).
            refRfData (np.ndarray): RF data of the phantom (n lines x m samples).
            apertureRadiusCm (float): Aperture radius in cm.
            roiDepth (int): Depth of the start of the ROI in samples.
            
        Returns:
            Tuple: Effective scatterer diameter (µm) and concentration of the ROI (dB/mm^3).
        """
        windowDepthCm = rfData.shape[0]*self.ultrasoundImage.axialResRf/10 # cm
        windowLengthCm = rfData.shape[1]*self.ultrasoundImage.lateralResRf/10 # cm. Assuming this unit, but not explicitly stated in paper
        q = apertureRadiusCm / windowDepthCm

        f, ps = computeHanningPowerSpec(rfData, self.config.analysisFreqBand[0], self.config.analysisFreqBand[1],
                                     self.config.samplingFrequency)
        _, refPs = computeHanningPowerSpec(refRfData, self.config.analysisFreqBand[0], self.config.analysisFreqBand[1],
                                     self.config.samplingFrequency)
        
        ps = 10*np.log10(ps) # dB
        refPs = 10*np.log10(refPs) # dB
        
        f *= 1e-6 # Hz -> MHz
        s = np.subtract(ps-refPs, 10*np.log10(f**4))
        p = np.polyfit(f**2, s, 1)
        m = abs(p[0])
        b1 = p[1]
        esd = 2*(m/((11.6*(q**2))+52.8)) ** 0.5 # µm

        b0 = self.attenuationCoef
        eac = 64 * (
            (10 ** ((b1 + 2*windowDepthCm*b0) / 10)) 
            / (185 * windowLengthCm * (q**2) * esd**6)
        ) # dB/mm^3

        return esd, eac
    
    
    
    
###################################################################################
# H-scan
###################################################################################
class Hscan:
    """Class for computing the H-scan parameters."""
    
    class GaussinaHermiteWavelet:
        """Class for computing the Gaussian Hermite wavelet."""
        
        ###################################################################################
        # Constructor method (initializer)
        ###################################################################################
        def __init__(self, order, fs, sigma, wavelet_duration, visualize) -> None:
                    
            self.order = order
            self.fs = fs 
            self.sigma = sigma
            self.wavelet_duration = wavelet_duration
            self.visualize = visualize
        
            self.time = None
            self.wavelet = None

            self.__run()
            
        ###################################################################################
        # Run method
        ###################################################################################
        def __run(self):
            
            self.build_time_array()
            self.build_wavelet()
            self.get_central_freq_of_wavelet()
            self.plot()
        
        ###################################################################################
        # Build time array
        ###################################################################################
        def build_time_array(self):
            logging.info("Building time array...")

            # Get the sampling frequency rate
            time_step_second = 1 / (self.fs)
            logging.debug(f"Calculated time step (seconds): {time_step_second}")

            # Create a time array for the wavelet
            # Ensure the wavelet duration is a float for np.arange
            half_duration = self.wavelet_duration / 2  # Use float division
            self.time = np.arange(-half_duration, half_duration, time_step_second)
                        
            logging.info(f"Time array created with length: {len(self.time)}")
            
        ###################################################################################
        # Build wavelet
        ###################################################################################
        def build_wavelet(self):
            logging.debug(f"Starting normalized_hermite_polynomial with order={self.order}, time={self.time}, sigma={self.sigma}")

            # Physicists' Hermite polynomial
            H_n = hermite(self.order)
            logging.debug(f"Hermite polynomial of order {self.order} generated.")

            # Normalization factor (assuming custom energy calculation)
            energy = np.sqrt(np.pi / 2) * (factorial(2 * self.order) / (2**self.order * factorial(self.order)))
            normalization_factor = 1.0 / np.sqrt(energy)
            logging.debug(f"Calculated energy={energy} and normalization_factor={normalization_factor}")

            # Gaussian window
            gaussian_window = np.exp(-(self.time**2) / (1 * self.sigma**2))
            logging.debug(f"Computed Gaussian window with values: {gaussian_window}")

            # Construct the wavelet
            self.wavelet = normalization_factor * H_n(self.time / self.sigma) * gaussian_window
            logging.debug(f"Generated wavelet with values: {self.wavelet}")

        ###################################################################################
        # Get central frequency of wavelet
        ###################################################################################
        def get_central_freq_of_wavelet(self):
            logging.info("Starting central frequency calculation.")
            
            # Perform Fourier Transform
            fft_wavelet = np.fft.fft(self.wavelet)
            logging.debug(f"FFT of wavelet: {fft_wavelet}")

            # Convert sampling rate to Hz and calculate dt
            dt = 1 / self.fs

            # Compute the frequency bins
            n = len(self.wavelet)
            freq_bins = np.fft.fftfreq(n, d=dt)
            logging.debug(f"Frequency bins: {freq_bins}")

            # Compute the Power Spectrum
            power_spectrum = np.abs(fft_wavelet) ** 2
            logging.debug(f"Power Spectrum: {power_spectrum}")

            # Limit to positive frequencies
            positive_freqs = freq_bins > 0
            positive_freq_bins = freq_bins[positive_freqs]
            positive_power_spectrum = power_spectrum[positive_freqs]

            # Find the frequency with maximum amplitude in the positive spectrum
            max_amplitude_freq = positive_freq_bins[np.argmax(positive_power_spectrum)]
            logging.info(f"Frequency with maximum amplitude: {max_amplitude_freq / 1e6:.2f} MHz")

            # Replace print with logging
            logging.info(f"Frequency with Maximum Amplitude: {max_amplitude_freq / 1e6:.2f} MHz")

        ###################################################################################
        # Plot
        ###################################################################################
        def plot(self, show_negative_freqs=False, shift_time_positive=True):
            logging.info("Starting the plot process.")
            
            if self.visualize:
                logging.info("Visualization is enabled.")
                
                plt.figure(figsize=(12, 4))
                logging.info("Figure created with size 12x4.")

                # Plot the Hermite wavelet
                plt.subplot(1, 2, 1)
                
                # Shift time to positive if the option is enabled
                time_to_plot = self.time * 1e6
                if shift_time_positive:
                    time_to_plot = (self.time - self.time.min()) * 1e6
                    logging.info("Time shifted to positive values.")

                plt.plot(time_to_plot, self.wavelet, label=f'GH{self.order}')  # Time in µs
                
                # Shift vertical lines if time is shifted
                sigma_shift = self.time.min() if shift_time_positive else 0
                plt.axvline(x=(3 * self.sigma - sigma_shift) * 1e6, color='blue', linestyle='--', label='+3\u03C3')
                plt.axvline(x=(-3 * self.sigma - sigma_shift) * 1e6, color='blue', linestyle='--', label='-3\u03C3')
                
                plt.title('Hermite Wavelets')
                plt.xlabel('Time [µs]')
                plt.ylabel('Amplitude')
                plt.legend()
                plt.grid(True)
                logging.info("Hermite wavelet plot created with time scaled to microseconds.")

                # FFT and frequency response
                logging.info("Starting FFT calculation.")
                wavelet_fft = fft(self.wavelet)
                freqs = np.fft.fftfreq(len(wavelet_fft), d=(self.time[1] - self.time[0]))  # Frequency vector
                fft_magnitude = np.abs(wavelet_fft)  # Magnitude of FFT
                logging.info("FFT calculation completed.")

                plt.subplot(1, 2, 2)
                if show_negative_freqs:
                    plt.plot(freqs / 1e6, fft_magnitude, label=f'FFT of GH{self.order}')  # Full spectrum
                    plt.title('Full Frequency Spectrum of Hermite Wavelets')
                else:
                    positive_mask = freqs >= 0
                    plt.plot(freqs[positive_mask] / 1e6, fft_magnitude[positive_mask], label=f'FFT of GH{self.order}')  # Positive only
                    plt.title('Positive Frequency Spectrum of Hermite Wavelets')
                
                plt.xlabel('Frequency [MHz]')
                plt.ylabel('Magnitude')
                plt.legend()
                plt.grid()
                logging.info("Frequency response plot created.")

                plt.tight_layout()
                plt.show()
                logging.info("Plots displayed successfully.")
            else:
                logging.info("Visualization is disabled; no plots will be shown.")

    ###################################################################################
    # Constructor
    ###################################################################################
    def __init__(self,
                 signal_nd: np.ndarray,
                 row_axis: int,
                 signal_axis: int,
                 frame_axis: int,
                 wavelet_GHx_params_1: dict,
                 wavelet_GHx_params_2: dict,
                 ) -> None:
        
        # input arguments
        self.signal_nd = signal_nd
        self.signal_axis = signal_axis
        self.row_axis = row_axis
        self.frame_axis = frame_axis
        self.wavelet_GHx_params_1 = wavelet_GHx_params_1
        self.wavelet_GHx_params_2 = wavelet_GHx_params_2
        self.wavelet_GH1 = self.GaussinaHermiteWavelet(**wavelet_GHx_params_1)
        self.wavelet_GH2 = self.GaussinaHermiteWavelet(**wavelet_GHx_params_2)
                                
        self.convolved_signal_with_ghx_1_nd = None
        self.convolved_signal_with_ghx_2_nd = None
        self.convolved_signal_with_ghx_1_envelope_nd = None
        self.convolved_signal_with_ghx_2_envelope_nd = None
        
        self.envelope_nd = None

        self.__run()

    ###################################################################################
    # Compute H-scan
    ###################################################################################
    def __run(self):
                
        # convolved signals
        self.convolve_signal_with_wavelets_nd()
        self.set_envelope_of_convolved_signals_nd() 
        self.set_envelope_of_signals_nd()
        
    ###################################################################################
    # Convolve 3D signal
    ###################################################################################
    def _convolve_signal_nd(self,
                            signal_nd: np.ndarray,
                            wavelet_1d: np.ndarray,
                            signal_axis: int) -> np.ndarray:
        """
        Convolve an n-dimensional signal with a 1D wavelet along the specified axis.
        This method is dimension-independent and works for any signal dimension.
        
        Args:
            signal_nd (np.ndarray): N-dimensional signal array to be convolved
            wavelet_1d (np.ndarray): 1D wavelet array to convolve with
            signal_axis (int): Axis along which to perform convolution
            
        Returns:
            np.ndarray: Convolved signal with same dimensions as input signal
            
        Raises:
            ValueError: If signal_axis is invalid or signal/wavelet dimensions are incompatible
        """
        try:
                
            if signal_axis >= signal_nd.ndim:
                raise ValueError(f"Axis {signal_axis} is out of bounds for signal with {signal_nd.ndim} dimensions")
            
            logging.info(f"Starting convolution of {signal_nd.ndim}D signal along axis {signal_axis}")
            
            # Create the convolution function for a single 1D signal
            def convolve_1d(signal_1d):
                return np.convolve(signal_1d, wavelet_1d, mode='same')
            
            # Apply the convolution along the specified axis using np.apply_along_axis
            # This automatically handles any number of dimensions
            convolved_signal = np.apply_along_axis(
                func1d=convolve_1d,
                axis=signal_axis,
                arr=signal_nd
            )
            
            logging.info(f"Successfully convolved {signal_nd.ndim}D signal with shape {signal_nd.shape}")
            return convolved_signal
            
        except Exception as e:
            logging.error(f"Error during convolution: {str(e)}")
            raise

    ###################################################################################
    # Convolve signal with wavelets 3D
    ###################################################################################
    def convolve_signal_with_wavelets_nd(self):
        logging.info("Starting convolution with wavelets")

        # Convolve with the first wavelet
        self.convolved_signal_with_ghx_1_nd = self._convolve_signal_nd(
            signal_nd=self.signal_nd,
            wavelet_1d=self.wavelet_GH1.wavelet,
            signal_axis=self.signal_axis
        )
        logging.info("Convolution with wavelet 1 completed")
        
        # Convolve with the second wavelet
        self.convolved_signal_with_ghx_2_nd = self._convolve_signal_nd(
            signal_nd=self.signal_nd,
            wavelet_1d=self.wavelet_GH2.wavelet,
            signal_axis=self.signal_axis
        )
        logging.info("Convolution with wavelet 2 completed")
                
    ###################################################################################
    # Get envelope of convolved signal 3D
    ###################################################################################
    def set_envelope_of_convolved_signals_nd(self):
        """Get the envelope of the convolved signal 3D using Hilbert transform.
        
        This method computes the envelope of both convolved signals (GH1 and GH2) using the Hilbert transform.
        The envelope is computed along the specified signal axis.
        """
        logging.info("Starting to compute the envelope of convolved signals in 3D.")

        try:
            # Compute envelope for first convolved signal (GH1)
            logging.info("Calculating envelope for the first convolved signal (GH1).")
            self.convolved_signal_with_ghx_1_envelope_nd = np.abs(hilbert(self.convolved_signal_with_ghx_1_nd,
                                                                          axis=self.signal_axis))
            logging.info("Envelope for the first convolved signal computed successfully.")

            # Compute envelope for second convolved signal (GH2)
            logging.info("Calculating envelope for the second convolved signal (GH2).")
            self.convolved_signal_with_ghx_2_envelope_nd = np.abs(hilbert(self.convolved_signal_with_ghx_2_nd,
                                                                          axis=self.signal_axis))
            logging.info("Envelope for the second convolved signal computed successfully.")

        except Exception as e:
            logging.error(f"An error occurred while computing the envelopes: {e}")
            raise  # Re-raise the exception after logging it
        finally:
            logging.info("Envelope computation process completed.")

    ###################################################################################
    # Get envelope of signals 3D
    ###################################################################################
    def set_envelope_of_signals_nd(self):
        """Get the envelope of the signals 3D."""
        self.envelope_nd = np.abs(hilbert(self.signal_nd, axis=self.signal_axis))



###################################################################################
# Backscatter coefficient
###################################################################################
class BSC:
    """Class for computing the backscatter coefficient for the ROI.
    """
    def __init__(self):
        pass
    
    def compute_BSC(self):
        """Compute the backscatter coefficient for the ROI.
        """
        pass


###################################################################################
# Depth and time array generator
###################################################################################
class DepthTimeArrayGenerator:
    """Class for generating depth and time arrays for the ROI.
    
    This class generates arrays for depth and time values based on signal parameters.
    The depth array represents the penetration depth in centimeters, while the time
    array represents the corresponding time values in seconds.
    
    Attributes:
        signal_length (int): Length of the signal in samples
        sampling_frequency (float): Sampling frequency in Hz
        speed_of_sound (float): Speed of sound in m/s
        penetration_depth (float): Maximum penetration depth in cm
        depth_array (np.ndarray): Array of depth values in cm
        time_array (np.ndarray): Array of time values in seconds
    """
    def __init__(self,
                 signal_len: int,
                 sampling_frequency_MHz: float,
                 speed_of_sound_m_s: float):
        
        # input arguments
        self.signal_len = signal_len
        self.sampling_frequency_MHz = sampling_frequency_MHz
        self.speed_of_sound_m_s = speed_of_sound_m_s
        
        # computed attributes
        self.depth_array_cm = None
        self.time_array_s = None
        
        self.__run()
        
    ###################################################################################
    # Run
    ###################################################################################
    def __run(self):
        
        self.set_time_array()
        self.set_depth_array()
        
    ###################################################################################
    # Set time array
    ###################################################################################
    def set_time_array(self):
        self.time_array_s = np.arange(self.signal_len) / self.sampling_frequency_MHz * 1e-6
        
    ###################################################################################
    # Set depth array
    ###################################################################################
    def set_depth_array(self):
        self.depth_array_cm = (self.speed_of_sound_m_s * self.time_array_s / 2) * 100  # Convert to cm
        
        




###################################################################################
# Central frequency shift
###################################################################################
class CentralFrequencyShift:
    """Class for computing the central frequency shift for the ROI.
    
    This class implements methods to analyze the central frequency shift of ultrasound signals
    using Short-Time Fourier Transform (STFT) and Gaussian fitting. It can be used to estimate
    attenuation coefficients based on frequency shifts with depth.
    
    Attributes:
        signal (np.ndarray): Input signal to analyze
        fs (float): Sampling frequency in Hz
        time_array (np.ndarray): Time values corresponding to the signal
        speed_of_sound (float): Speed of sound in m/s (default: 1540)
        stft_params (dict): Parameters for STFT computation
    """
    
    ###################################################################################
    # Constructor
    ###################################################################################
    def __init__(self,
                 signal_1d: np.ndarray,
                 sampling_frequency_MHz: float,
                 time_array_s: np.ndarray, 
                 depth_array_cm: np.ndarray,
                 speed_of_sound_m_s: float = 1540,
                 stft_params: dict = None):
        """Initialize the CentralFrequencyShift class.
        
        Args:
            signal (np.ndarray): Input signal to analyze
            fs (float): Sampling frequency in Hz
            time_array (np.ndarray): Time values corresponding to the signal
            speed_of_sound (float, optional): Speed of sound in m/s. Defaults to 1540.
            stft_params (dict, optional): Parameters for STFT computation. If None, uses defaults.
        """
        # input arguments
        self.signal_1d = signal_1d
        self.fs = sampling_frequency_MHz * 1e6
        self.time_array_s = time_array_s
        self.depth_array_cm = depth_array_cm
        self.speed_of_sound_m_s = speed_of_sound_m_s
        self.stft_params = stft_params
            
        # Initialize computed attributes
        self.frequencies_stft = None
        self.times_stft = None
        self.Zxx_stft = None
        self.amplitudes_stft = None
        self.center_frequencies = None
        self.fitted_sigmas = None
        self.gaussian_fits = None
        
        self.__run()
        
    ###################################################################################
    # Main method to compute central frequency shift and estimate attenuation coefficient.
    ###################################################################################
    def __run(self):

        self.compute_stft()
        self.adjust_depth_array()
        self.fit_gaussian_peaks()    
        self.plot_stft_spectrogram()
        self.plot_frequency_shift()
        self.plot_signal_segments()
        
    ###################################################################################
    # Compute STFT
    ###################################################################################
    def compute_stft(self):
        """Compute the STFT of the signal."""
        self.frequencies_stft, self.times_stft, self.Zxx_stft = stft(self.signal_1d, 
                                        fs=self.fs,
                                        nperseg=self.stft_params['nperseg'],
                                        noverlap=self.stft_params['overlap']
                                        )
        
        # Compute the amplitudes of the STFT
        self.amplitudes_stft = np.abs(self.Zxx_stft)

    ###################################################################################
    # Compute depth values
    ###################################################################################
    def adjust_depth_array(self):
        """Adjust depth array to match the number of STFT time segments."""
        
        # Interpolate depth values to align with STFT time segments
        if len(self.depth_array_cm) != len(self.times_stft):
            self.depth_array_cm = np.interp(
                np.linspace(0, len(self.depth_array_cm) - 1, len(self.times_stft)),
                np.arange(len(self.depth_array_cm)),
                self.depth_array_cm
            )
        
        # Remove the last depth value to avoid edge effects
        self.depth_array_cm = self.depth_array_cm[:-1]

    ###################################################################################
    # Fit Gaussian peaks
    ###################################################################################
    def fit_gaussian_peaks(self):
        """Fit Gaussian curves to frequency spectra at each depth."""
        
        center_frequencies = []
        fitted_sigmas = []
        gaussian_fits = []

        for i in range(len(self.depth_array_cm)):
            spectrum = self.amplitudes_stft[:, i]
            
            # Initial guesses for Gaussian fit
            initial_guess = [
                np.max(spectrum),
                self.frequencies_stft[np.argmax(spectrum)],
                1e6
            ]
            
            try:
                # Fit Gaussian to the frequency spectrum
                popt, _ = curve_fit(
                    self.gaussian,
                    self.frequencies_stft,
                    spectrum,
                    p0=initial_guess
                )
                fitted_amplitude, fitted_center, fitted_sigma = popt
                center_frequencies.append(fitted_center)
                fitted_sigmas.append(fitted_sigma)
                gaussian_fits.append(popt)
            except RuntimeError:
                # Fallback to max frequency if fit fails
                center_frequencies.append(self.frequencies_stft[np.argmax(spectrum)])
                fitted_sigmas.append(None)
                gaussian_fits.append(None)

        # Convert center frequencies to MHz
        self.center_frequencies = np.array(center_frequencies) / 1e6
        self.fitted_sigmas = fitted_sigmas
        self.gaussian_fits = gaussian_fits

    ###################################################################################
    # Gaussian function
    ###################################################################################
    def gaussian(self, x, a, x0, sigma):
        """Gaussian function for peak fitting."""
        return a * np.exp(-((x - x0) ** 2) / (2 * sigma ** 2))

    ###################################################################################
    # Plot STFT spectrogram
    ###################################################################################
    def plot_stft_spectrogram(self):
        """Plot the STFT spectrogram."""
        plt.figure(figsize=(10, 6))
        plt.pcolormesh(
            self.times_stft,
            self.frequencies_stft / 1e6,
            np.log(self.amplitudes_stft),
            shading='gouraud',
            cmap='jet'
        )
        plt.colorbar(label="Amplitude")
        plt.xlabel("Time (s)")
        plt.ylabel("Frequency (MHz)")
        plt.title("STFT Spectrogram of the Signal")
        plt.ylim([0, np.max(self.frequencies_stft) / 1e6])
        plt.show()

    ###################################################################################
    # Plot frequency shift
    ###################################################################################
    def plot_frequency_shift(self):
        """Plot frequency shift results with curve fitting."""
        plt.figure(figsize=(10, 6))
        
        # Filter out invalid data points
        valid_indices = [i for i in range(len(self.fitted_sigmas)) 
                        if self.fitted_sigmas[i] is not None]
        z_values_filtered = np.array(self.depth_array_cm)[valid_indices]
        center_frequencies_filtered = np.array(self.center_frequencies)[valid_indices]
        
        # Plot observed center frequencies
        plt.scatter(
            z_values_filtered,
            center_frequencies_filtered,
            label="Observed Center Frequencies",
            color="red",
            marker="o"
        )
        
        # Define and plot linear model
        def linear_model(z, alpha):
            return self.center_frequencies[0] - 4 * alpha * z * (
                np.array(self.fitted_sigmas[:len(z)])**2
            ) / 1e12
        
        plt.plot(
            z_values_filtered,
            linear_model(z_values_filtered, 1.0),  # Using alpha=1.0 as example
            linestyle="--",
            color="blue",
            label="Linear Model Fit"
        )
        
        plt.xlabel("Depth (cm)")
        plt.ylabel("Center Frequency (MHz)")
        plt.title("Curve Fitting to Estimate Attenuation Coefficient")
        plt.legend()
        plt.grid()
        plt.show()

    ###################################################################################
    # Plot signal segments
    ###################################################################################
    def plot_signal_segments(self):
        """Plot individual signal segments with their frequency spectra."""
        for i, t in enumerate(self.times_stft):
            fig, axes = plt.subplots(1, 2, figsize=(14, 4))
            
            # Plot signal segment
            segment = self.signal_1d[int(t * self.fs): 
                                int((t + self.stft_params['nperseg'] / self.fs) * self.fs)]
            axes[0].plot(segment, color='blue')
            axes[0].set_title(f"Signal Segment at Depth {self.depth_array_cm[i]:.2f} cm")
            axes[0].set_xlabel("Sample Index")
            axes[0].set_ylabel("Amplitude")
            
            # Plot frequency spectrum
            axes[1].plot(
                self.frequencies_stft / 1e6,
                self.amplitudes_stft[:, i],
                color='green',
                label="Observed Spectrum"
            )
            
            if self.gaussian_fits[i] is not None:
                fitted_curve = self.gaussian(
                    self.frequencies_stft,
                    *self.gaussian_fits[i]
                )
                axes[1].plot(
                    self.frequencies_stft / 1e6,
                    fitted_curve,
                    color='red',
                    linestyle="--",
                    label="Gaussian Fit"
                )
                axes[1].axvline(
                    self.center_frequencies[i],
                    color='blue',
                    linestyle=":",
                    label=f"Peak @ {self.center_frequencies[i]:.2f} MHz"
                )
            
            axes[1].set_title(f"Frequency Spectrum at Depth {self.depth_array_cm[i]:.2f} cm")
            axes[1].set_xlabel("Frequency (MHz)")
            axes[1].set_ylabel("Amplitude")
            axes[1].legend()
            
            plt.tight_layout()
            plt.show()



###################################################################################
# attenuation coefficient estimation
###################################################################################
class AttenuationCoefficientEstimation:
    """Class for computing the attenuation coefficient based on central frequency shift for the ROI.
    """
    def __init__(self):
        pass
    
    def compute_ac_central_frequency_shift(self):
        """Compute the attenuation coefficient based on central frequency shift for the ROI.
        """
        pass
    
    def compute_ac_signal_energy_slope(self):
        """Compute the attenuation coefficient based on signal energy slope for the ROI.
        """
        pass





    