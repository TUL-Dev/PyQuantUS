from typing import List

import numpy as np
from PIL import Image, ImageDraw
from scipy.signal import hilbert
from scipy.optimize import curve_fit

from pyquantus.utc.objects import UltrasoundImage, AnalysisConfig, Window
from pyquantus.utc.transforms import computeHanningPowerSpec, computeSpectralParams, checkKwargs

class UtcResults:
    """Class to store analysis results from UTC analysis of an image.
    """
    def __init__(self):
        self.mbf: float  # midband fit (dB)
        self.ss: float  # spectral slope (dB/MHz)
        self.si: float  # spectral intercept (dB)
        self.nps: np.ndarray  # normalized power spectrum
        self.ps: np.ndarray  # image power spectrum
        self.rPs: np.ndarray  # phantom power spectrum
        self.f: np.ndarray  # frequency array (Hz)

class UtcAnalysis:
    """Complete ultrasound tissue characterization (UTC) analysis of an ultrasound image given 
    a corresponding phantom image.

    This class supports both scan converted and non-scan converted images. UTC analysis
    is performed on each window generated by the `generateRoiWindows` method. Utc 
    analysis corresponds to the computation of tissue characterization-related parameters.
    The midband fit, spectral slope, and spectral intercept parameters have been validated using
    the frequency domain of each window. The Nakagami parameters, attenuation coefficient,
    backscatter coefficient, effective scatterer diameter, and effective scatterer concentration
    all have been implemented and reviewed, but still have not been validated in practice.
    
    Args:
        kwargTypes (dict): Dictionary of required kwargs and their types.
        kwargs (Any): Additional keyword arguments (not used in base class).

    Attributes:
        ultrasoundImage (UltrasoundImage): Stores image and RF info for image and phantom.
        config (AnalysisConfig): Stores analysis configuration parameters.
        roiWindows (List[Window]): List of windows generated by `generateRoiWindows`.
        waveLength (float): Wavelength of the ultrasound signal in mm.
        scSplineX (np.ndarray): Spline x-coordinates in scan converted coordinates.
        splineX (np.ndarray): Spline x-coordinates in pre-scan converted coordinates.
        scSplineY (np.ndarray): Spline y-coordinates in scan converted coordinates.
        splineY (np.ndarray): Spline y-coordinates in pre-scan converted coordinates.
        singleWindow (Window): Window object containing the entire ROI.
    """
    
    def __init__(self, kwargTypes, **kwargs):
        self.ultrasoundImage: UltrasoundImage
        self.config: AnalysisConfig
        self.scSplineX: np.ndarray # pix
        self.splineX: np.ndarray # pix
        self.scSplineY: np.ndarray # pix
        self.splineY: np.ndarray # pix
        
        self.roiWindows: List[Window] = []
        self.ResultsClass = UtcResults
        self.singleWindow: Window
        assert checkKwargs(kwargTypes, kwargs), "Invalid kwargs"

    def splineToPreSc(self):
        """Convert spline coordinates from scan converted to pre-scan converted."""
        self.splineX = np.array([self.ultrasoundImage.xmap[int(y), int(x)] for x, y in zip(self.scSplineX, self.scSplineY)])
        self.splineY = np.array([self.ultrasoundImage.ymap[int(y), int(x)] for x, y in zip(self.scSplineX, self.scSplineY)])

    def generateRoiWindows(self):
        """Generate windows for UTC analysis based on user-defined spline."""
        if not hasattr(self, 'splineX') or not hasattr(self, 'splineY'):
            self.splineToPreSc()
        
        # Some axial/lateral dims
        axialPixSize = round(self.config.axWinSize / self.ultrasoundImage.axialResRf) # mm/(mm/pix)
        lateralPixSize = round(self.config.latWinSize / self.ultrasoundImage.lateralResRf) # mm(mm/pix)
        axial = list(range(self.ultrasoundImage.rf.shape[0]))
        lateral = list(range(self.ultrasoundImage.rf.shape[1]))

        # Overlap fraction determines the incremental distance between ROIs
        axialIncrement = axialPixSize * (1 - self.config.axialOverlap)
        lateralIncrement = lateralPixSize * (1 - self.config.lateralOverlap)

        # Determine ROIS - Find Region to Iterate Over
        axialStart = max(min(self.splineY), axial[0])
        axialEnd = min(max(self.splineY), axial[-1] - axialPixSize)
        lateralStart = max(min(self.splineX), lateral[0])
        lateralEnd = min(max(self.splineX), lateral[-1] - lateralPixSize)

        self.roiWindows = []

        # Determine all points inside the user-defined polygon that defines analysis region
        # The 'mask' matrix - "1" inside region and "0" outside region
        # Pair x and y spline coordinates
        spline = []
        if len(self.splineX) != len(self.splineY):
            print("Spline has unequal amount of x and y coordinates")
            return
        for i in range(len(self.splineX)):
            spline.append((self.splineX[i], self.splineY[i]))

        img = Image.new("L", (self.ultrasoundImage.rf.shape[1], self.ultrasoundImage.rf.shape[0]), 0)
        ImageDraw.Draw(img).polygon(spline, outline=1, fill=1)
        mask = np.array(img)

        for axialPos in np.arange(axialStart, axialEnd, axialIncrement):
            for lateralPos in np.arange(lateralStart, lateralEnd, lateralIncrement):
                # Convert axial and lateral positions in mm to Indices
                axialAbsAr = abs(axial - axialPos)
                axialInd = np.where(axialAbsAr == min(axialAbsAr))[0][0]
                lateralAbsAr = abs(lateral - lateralPos)
                lateralInd = np.where(lateralAbsAr == min(lateralAbsAr))[0][0]

                # Determine if ROI is Inside Analysis Region
                maskVals = mask[
                    axialInd : (axialInd + axialPixSize),
                    lateralInd : (lateralInd + lateralPixSize),
                ]

                # Define Percentage Threshold
                totalNumberOfElementsInRegion = maskVals.size
                numberOfOnesInRegion = len(np.where(maskVals == 1)[0])
                percentageOnes = numberOfOnesInRegion / totalNumberOfElementsInRegion

                if percentageOnes > self.config.windowThresh:
                    # Add ROI to output structure, quantize back to valid distances
                    newWindow = Window(self.ResultsClass)
                    newWindow.left = int(lateral[lateralInd])
                    newWindow.right = int(lateral[lateralInd + lateralPixSize - 1])
                    newWindow.top = int(axial[axialInd])
                    newWindow.bottom = int(axial[axialInd + axialPixSize - 1])
                    self.roiWindows.append(newWindow)
                    
    def computeBaseParamapVals(self, scanRfWindow: np.ndarray, phantomRfWindow: np.ndarray, window: Window):
        """Compute base UTC parameters for a single window in the ROI used as part of a parametric map.
        These include MBF, SS, and SI. Also stores NPS, PS, rPS, and f in window.results.
        
        Args:
            scanRfWindow (np.ndarray): RF data of the window in the scan image.
            phantomRfWindow (np.ndarray): RF data of the window in the phantom image.
            window (Window): Window object to store results.
        """
        # Compute normalized power spectrum
        f, ps = computeHanningPowerSpec(
            scanRfWindow, self.config.transducerFreqBand[0], 
            self.config.transducerFreqBand[1], self.config.samplingFrequency
        ) 
        ps = 20 * np.log10(ps)
        f, rPs = computeHanningPowerSpec(
            phantomRfWindow, self.config.transducerFreqBand[0], 
            self.config.transducerFreqBand[1], self.config.samplingFrequency
        )
        rPs = 20 * np.log10(rPs)
        nps = np.asarray(ps) - np.asarray(rPs)
        
        window.results.nps = nps
        window.results.ps = np.asarray(ps)
        window.results.rPs = np.asarray(rPs)
        window.results.f = np.asarray(f)

        mbf, _, _, p = computeSpectralParams(nps, f, self.config.analysisFreqBand[0], self.config.analysisFreqBand[1])
        window.results.mbf = mbf # dB
        window.results.ss = p[0]*1e6 # dB/MHz
        window.results.si = p[1] # dB
                    
    def computeParamapVals(self, scanRfWindow: np.ndarray, phantomRfWindow: np.ndarray, window: Window):
        """Compute UTC parameters for a single window in the ROI used as part of a parametric map.
        
        Args:
            scanRfWindow (np.ndarray): RF data of the window in the scan image.
            phantomRfWindow (np.ndarray): RF data of the window in the phantom image.
            window (Window): Window object to store results.
        """
        self.computeBaseParamapVals(scanRfWindow, phantomRfWindow, window)
        
    def computeSingleWindowVals(self, scanRfWindow: np.ndarray, phantomRfWindow: np.ndarray):
        """Compute UTC parameters for a single window containing the entire ROI.
        
        Args:
            scanRfWindow (np.ndarray): RF data of the window in the scan image.
            phantomRfWindow (np.ndarray): RF data of the window in the phantom image.
        """
        self.computeBaseParamapVals(scanRfWindow, phantomRfWindow, self.singleWindow)

    def computeParamaps(self) -> int:
        """Compute UTC parameters for each window in the ROI, creating a parametric map.
        
        Returns:
            int: 0 if successful, -1 if `generateRoiWindows` has not been 
            run or if windows are too large for ROI.
        """
        if not len(self.roiWindows):
            print("Run 'generateRoiWindows' first")
            return -1

        for window in self.roiWindows:
            imgWindow = self.ultrasoundImage.rf[window.top: window.bottom+1, window.left: window.right+1]
            refWindow = self.ultrasoundImage.phantomRf[window.top: window.bottom+1, window.left: window.right+1]
            self.computeParamapVals(imgWindow, refWindow, window)
        
        return 0
    
    def computeSingleWindow(self):
        minLeft = min([window.left for window in self.roiWindows])
        maxRight = max([window.right for window in self.roiWindows])
        minTop = min([window.top for window in self.roiWindows])
        maxBottom = max([window.bottom for window in self.roiWindows])
        
        self.singleWindow = Window(self.ResultsClass)
        imgWindow = self.ultrasoundImage.rf[minTop: maxBottom+1, minLeft: maxRight+1]
        refWindow = self.ultrasoundImage.phantomRf[minTop: maxBottom+1, minLeft: maxRight+1]
        self.computeSingleWindowVals(imgWindow, refWindow)

    @property
    def bmodeSplineX(self):
        """Get B-mode x-coordinates in same coordinates as bmode image."""
        if hasattr(self.ultrasoundImage, 'scConfig'):
            return self.scSplineX
        return self.splineX
    
    @property
    def bmodeSplineY(self):
        """Get B-mode y-coordinates in same coordinates as bmode image."""
        if hasattr(self.ultrasoundImage, 'scConfig'):
            return self.scSplineY
        return self.splineY
    
    @bmodeSplineX.setter
    def bmodeSplineX(self, value: np.ndarray):
        """Set B-mode x-coordinates in same coordinates as bmode image."""
        if hasattr(self.ultrasoundImage, 'scConfig'):
            self.scSplineX = value
        else:
            self.splineX = value
            
    @bmodeSplineY.setter
    def bmodeSplineY(self, value: np.ndarray):
        """Set B-mode y-coordinates in same coordinates as bmode image."""
        if hasattr(self.ultrasoundImage, 'scConfig'):
            self.scSplineY = value
        else:
            self.splineY = value